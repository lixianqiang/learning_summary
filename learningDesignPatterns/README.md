# 设计原则  
## 开放封闭原则: 对扩展开放, 对修改封闭
>       通俗理解: 允许扩展, 禁止修改  
>                 允许扩展: 保证了软件的可扩展性和灵活性  
>                 禁止修改: 保证了系统的复用性和稳定性
## 里氏替换原则: 继承必须确保超类所拥有的性质在子类中仍然成立
>     通俗理解: 当子类继承父类以后, 要保证父类所拥有的功能子类也能"正确执行". 
>               该原则给出了一种继承关系(is-a)的标准, 怎么样的继承才是正确的继承关系. 
>               同时也告诉我们子类继承父类以后, 子类就不应该去重载父类原有的功能, 如果需要重载的话, 这时首要考虑的是: 它们的关系是否正确/合适吗？
## 依赖倒置原则: 高层模块不应该依赖低层模块, 两者都应该依赖其抽象; 抽象不应该依赖细节, 细节应该依赖抽象
>     通俗理解: 使用抽象编程, 将变化点封装在细节实现里
## 单一职责原则: 单一职责原则规定一个类应该有且仅有一个引起它变化的原因, 否则类应该被拆分
>     通俗理解: 一个类不应该有太多功能(职责), 类的功能(职责)应尽可能的单一, 当类的功能(职责)多于两个的时候, 就要考虑将类进行拆解
## 接口隔离原则: 客户端不应该被迫依赖于它不使用的方法; 此外, 一个类对另一个类的依赖应该建立在最小的接口上  
>     通俗理解: 1、一个接口（函数）不应该拥有太多功能, 因为有些功能对客户端（使用者）来说不是必须的
>              2、接口（函数）之间应尽量避免存在依赖关系. 最好是相互独立, 不存在依赖关系

## 迪米特原则: 一个对象应该对其他对象保持最少的了解. 该原则又称为最小知识原则
>     通俗理解: 当一个对象A与另一个对象B需要通信, 且它们之间没有任何关系时, 应该通过它们之间的共同朋友（第三方）进行交流（转发）

## 合成复用原则: 在软件复用时, 要尽量先使用组合/聚合等关联关系来实现, 其次才考虑使用继承关系来实现
>     通俗理解: 少用继承（is-a）多用组合（has-a）当需要使用继承时, 应该先考虑一下能否用组合进行替代.  
>                        复用分为继承复用和合成复用, 继承复用又称为白箱复用, 合成复用又称为黑箱复用. 其中合成复用又叫做组合/聚合复用

## 形参抽象原则(仅个人看法):软件设计过程中,应使用抽象类型作为函数形参
>     通俗理解: 抽象基类的(纯)虚函数的形参应全部或尽可能地使用抽象类型
>               在设计模式的学习过程中,发现(纯)虚函数的形参抽象化程度的高低会极大地影响该函数在重载实现相关功能应用时的难易程度
>               在重载实现的过程中,受限于形参的固有方法/属性而需要引入的更多外部对象,导致对象之间依赖关系变强,耦合度增大.降低了程序可复用性
>               形参的抽象化,使得重载过程可以方便变更形参的属性与方法,降低重载实现难度同时减少外部对象的引入,降低耦合度.
# 设计模式
## 创建型模式
+ ###  [単例模式][Singleton]
+ ### [原型模式][Prototype]
+ ### [工厂方法模式][FactoryMethod]
+ ### [抽象工厂模式][AbstractFactory]
+ ### [建造者模式][Builder]
## 结构型模式
+ ### [代理模式][Proxy]
+ ### [适配器模式][Adapter]
+ ### [桥接模式][Bridge]
+ ### [装饰器模式][Decorator]
+ ### [外观模式][Facade]
+ ### [享元模式][Flyweight]
+ ### [组合模式][Composite]
## 行为型模式
+ ### [模板方法模式][TemplateMethod]
+ ### [策略模式][Strategy]
+ ### [命令模式][Command]
+ ### [职责链模式][Chain]
+ ### [状态模式][State]
+ ### [观察者模式][Observer]
+ ### [中介者模式][Mediator]
+ ### [迭代器模式][Iterator]
+ ### [访问者模式][Visitor]
+ ### [备忘录模式][Memento]
+ ### [解释器模式][Interpreter]
## 其他
+ ### [模型-视图-控制器模式][MVC]
+ ### [空对象模式][NullObject]

[Singleton]: ./单例模式/README.md
[Prototype]: ./原型模式/README.md
[FactoryMethod]: ./工厂方法模式/README.md
[AbstractFactory]: ./抽象工厂模式/README.md
[Builder]: ./建造者模式/README.md
[Proxy]: ./代理模式/README.md
[Adapter]: ./适配器模式/README.md
[Bridge]: ./桥接模式/README.md
[Decorator]: ./装饰器模式/README.md
[Facade]: ./外观模式/README.md
[Flyweight]: ./享元模式/README.md
[Composite]: ./组合模式/README.md
[TemplateMethod]: ./模板方法模式/README.md
[Strategy]: ./策略模式/README.md
[Command]: ./命令模式/README.md
[Chain]: ./职责链模式/README.md
[State]: ./状态模式/README.md
[Observer]: ./观察者模式/README.md
[Mediator]: ./中介者模式/README.md
[Iterator]: ./迭代器模式/README.md
[Visitor]: ./访问者模式/README.md
[Memento]: ./备忘录模式/README.md
[Interpreter]: ./解释器模式/README.md
[MVC]: ./模型-视图-控制器模式/README.md
[NullObject]: ./空对象模式/README.md